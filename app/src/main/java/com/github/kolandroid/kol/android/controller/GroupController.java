package com.github.kolandroid.kol.android.controller;

import android.os.Bundle;
import android.support.annotation.CallSuper;
import android.view.View;
import android.widget.TabHost.TabSpec;

import com.github.kolandroid.kol.android.R;
import com.github.kolandroid.kol.android.screen.FragmentScreen;
import com.github.kolandroid.kol.android.screen.Screen;
import com.github.kolandroid.kol.android.util.CustomFragmentTabHost;
import com.github.kolandroid.kol.model.GroupModel;
import com.github.kolandroid.kol.model.GroupModel.ChildModel;
import com.github.kolandroid.kol.util.Logger;

import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

public abstract class GroupController<C extends ChildModel, M extends GroupModel<C>>
        extends UpdatableModelController<M> implements UpdatableController {
    /**
     * Autogenerated by eclipse.
     */
    private static final long serialVersionUID = 5797782671758587158L;
    private final Map<C, Controller> children;
    private transient CustomFragmentTabHost tabHost;

    public GroupController(M model) {
        super(model);

        this.children = new ConcurrentHashMap<>();
    }

    @Override
    public int getView() {
        return R.layout.tabs_view;
    }

    protected abstract Controller getController(C child);

    @CallSuper
    @Override
    public void attach(View view, M model, Screen host) {
        tabHost = (CustomFragmentTabHost) view
                .findViewById(R.id.tabs_tab_host);
        tabHost.setup(host.getActivity(), host.getChildFragmentManager());

        for (C child : model.getChildren()) {
            if (!children.containsKey(child)) {
                children.put(child, getController(child));
            }
            Controller c = children.get(child);
            Bundle bundle = FragmentScreen.prepare(c);
            TabSpec tab = tabHost.newTabSpec(child.getTitle()).setIndicator(child.getTitle());
            tabHost.addTab(tab, FragmentScreen.class, bundle);
        }

        tabHost.setCurrentTab(model.getActiveChild());
    }

    @Override
    protected void setModel(M model) {
        // Before setting the model, we maintain the currently selected tab
        if (tabHost != null) {
            Logger.log("GroupController", "Active child set to " + tabHost.getCurrentTab());
            model.setActiveChild(tabHost.getCurrentTab());
        }

        // And remove all cached controllers
        children.clear();

        super.setModel(model);
    }

    @Override
    public void connect(View view, M model, Screen host) {
        // Do nothing
    }


    @Override
    public void disconnect(Screen host) {
        super.disconnect(host);

        //Remember the currently selected child, in case we are restored
        if (tabHost != null) {
            getModel().setActiveChild(tabHost.getCurrentTab());
        }
    }
}
