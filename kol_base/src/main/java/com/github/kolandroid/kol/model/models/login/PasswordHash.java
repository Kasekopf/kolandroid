package com.github.kolandroid.kol.model.models.login;

import java.io.Serializable;
import java.nio.ByteBuffer;
import java.nio.CharBuffer;
import java.nio.charset.Charset;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.util.Arrays;

public class PasswordHash implements Serializable {
    /**
     * Autogenerated by eclipse.
     */
    private static final long serialVersionUID = -3913668500864943263L;

    // MD5 hashed password
    private final char[] hash;

    /**
     * Create a new PasswordHash around the provided password.
     * Take control of the lifecycle for the provided array
     *
     * @param password  The password to wrap
     * @param preHashed True if the password has already been MD5 hashed
     */
    public PasswordHash(char[] password, boolean preHashed) {
        if (preHashed)
            hash = password;
        else {
            this.hash = computeHash(password);
            Arrays.fill(password, '\0');
        }
    }

    /**
     * Compute the MD5 hash of the provided char[].
     * Does NOT take control of the lifecycle for the provided array,
     * nor control of the lifecycle for the returned array.
     *
     * @param password Compute the MD5 hash of this.
     * @return The MD5 hash of the provided char[]
     */
    private static char[] computeHash(char[] password) {
        try {
            // Convert the provided char[] to a byte[]
            ByteBuffer byteBuffer = Charset.forName("UTF-8").encode(CharBuffer.wrap(password));
            byte[] bytes = Arrays.copyOfRange(byteBuffer.array(),
                    byteBuffer.position(), byteBuffer.limit());

            // Get the MD5 hash of the argument as a hex string
            MessageDigest digester = MessageDigest.getInstance("MD5");
            byte[] digested = digester.digest(bytes);
            char[] result = getHexChars(digested);

            //Clear the generated bytes for security reasons
            // Note the generated CharBuffer is directly backed by the argument.
            // Since we do not take control of the argument, we shouldn't clear the CharBuffer
            Arrays.fill(byteBuffer.array(), (byte) 0);
            Arrays.fill(bytes, (byte) 0);
            Arrays.fill(digested, (byte) 0);

            return result;
        } catch (NoSuchAlgorithmException e) {
            e.printStackTrace();
            return new char[0];
        }
    }

    /**
     * Convert a byte[] to a hex char[]
     * Does NOT take control of the lifecycle for the provided array,
     * nor control of the lifecycle for the returned array.
     *
     * @param hash The bytes to convert.
     * @return
     */
    private static char[] getHexChars(final byte[] hash) {
        char[] result = new char[hash.length * 2];
        char[] digits = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'};

        for (int i = 0; i < hash.length; i++) {
            result[2 * i] = digits[(hash[i] & 0xF0) >> 4];
            result[2 * i + 1] = digits[hash[i] & 0xF];
        }

        return result;
    }

    /**
     * Given a challenge from KoL, complete the challenge by computing a specific hash based on the password.
     *
     * @param challenge The challenge to complete
     * @return The appropriate response to the challenge.
     */
    protected String completeChallenge(String challenge) {
        // Build a character array for "hash:challenge"
        char[] toHash = new char[hash.length + 1 + challenge.length()];
        System.arraycopy(hash, 0, toHash, 0, hash.length);
        toHash[hash.length] = ':';
        challenge.getChars(0, challenge.length(), toHash, hash.length + 1);

        //Once we've completed the challenge, the resulting string is MD5 encrypted and one-time-use
        // Thus we can safely keep it in String memory without compromising the KoL account
        String result = new String(computeHash(toHash));

        //Clear the generated array for security reasons
        Arrays.fill(toHash, '\0');

        return result;
    }

    /**
     * Clear the password data backing this hash, for security reasons.
     */
    public void clear() {
        Arrays.fill(hash, '\0');
    }

    /**
     * Get the data backing this hash.
     *
     * @return The char[] backing this hash.
     */
    public char[] getBaseHash() {
        return hash;
    }
}